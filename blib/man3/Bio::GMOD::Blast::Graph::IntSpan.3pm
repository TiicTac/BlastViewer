.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::GMOD::Blast::Graph::IntSpan 3"
.TH Bio::GMOD::Blast::Graph::IntSpan 3 "2005-11-09" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bio::GMOD::Blast::Graph::IntSpan \- Manages sets of integers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Bio::GMOD::Blast::Graph::IntSpan;
\&
\&    $Bio::GMOD::Blast::Graph::IntSpan::Empty_String = $string;
\&
\&    $set    = new   Bio::GMOD::Blast::Graph::IntSpan $set_spec;
\&    $valid  = valid Bio::GMOD::Blast::Graph::IntSpan $run_list;
\&    copy $set $set_spec;
\&
\&    $run_list   = run_list $set;
\&    @elements   = elements $set;
\&
\&    $u_set = union      $set $set_spec;
\&    $i_set = intersect  $set $set_spec;
\&    $x_set = xor        $set $set_spec;
\&    $d_set = diff       $set $set_spec;
\&    $c_set = complement $set;
\&
\&    equal       $set $set_spec;
\&    equivalent  $set $set_spec;
\&    superset    $set $set_spec;
\&    subset      $set $set_spec;
\&
\&    $n = cardinality $set;
\&
\&    empty       $set;
\&    finite      $set;
\&    neg_inf     $set;
\&    pos_inf     $set;
\&    infinite    $set;
\&    universal   $set;
\&
\&    member      $set $n;
\&    insert      $set $n;
\&    remove      $set $n;
\&
\&    $min = min  $set;
\&    $max = max  $set;
.Ve
.SH "REQUIRES"
.IX Header "REQUIRES"
Perl 5.002
.PP
Exporter
.SH "EXPORTS"
.IX Header "EXPORTS"
None
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::GMOD::Blast::Graph::IntSpan manages sets of integers.
It is optimized for sets that have long runs of consecutive integers.
These arise, for example, in .newsrc files, which maintain lists of articles:
.PP
.Vb 2
\&    alt.foo: 1\-21,28,31
\&    alt.bar: 1\-14192,14194,14196\-14221
.Ve
.PP
Sets are stored internally in a run-length coded form.
This provides for both compact storage and efficient computation.
In particular,
set operations can be performed directly on the encoded representation.
.PP
Bio::GMOD::Blast::Graph::IntSpan is designed to manage finite sets.
However, it can also represent some simple infinite sets, such as {x | x>n}.
This allows operations involving complements to be carried out consistently,
without having to worry about the actual value of \s-1MAXINT\s0 on your machine.
.SH "SET SPECIFICATIONS"
.IX Header "SET SPECIFICATIONS"
Many of the methods take a \fIset specification\fR.
There are four kinds of set specifications.
.SS "Empty"
.IX Subsection "Empty"
If a set specification is omitted, then the empty set is assumed.
Thus,
.PP
.Vb 1
\&    $set = new Bio::GMOD::Blast::Graph::IntSpan;
.Ve
.PP
creates a new, empty, set.  Similarly,
.PP
.Vb 1
\&    copy $set;
.Ve
.PP
removes all elements from \f(CW$set\fR.
.SS "Object reference"
.IX Subsection "Object reference"
If an object reference is given, it is taken to be a Bio::GMOD::Blast::Graph::IntSpan object.
.SS "Array reference"
.IX Subsection "Array reference"
If an array reference is given,
then the elements of the array are taken to be the elements of the set.
The array may contain duplicate elements.
The elements of the array may be in any order.
.SS "Run list"
.IX Subsection "Run list"
If a string is given, it is taken to be a \fIrun list\fR.
A run list specifies a set using a syntax similar to that in .newsrc files.
.PP
A run list is a comma-separated list of \fIruns\fR.
Each run specifies a set of consecutive integers.
The set is the union of all the runs.
.PP
Runs may be written in any of several forms.
.SS "Finite forms"
.IX Subsection "Finite forms"
.IP "n" 4
.IX Item "n"
{ n }
.IP "a\-b" 4
.IX Item "a-b"
{x | a<=x && x<=b}
.SS "Infinite forms"
.IX Subsection "Infinite forms"
.IP "(\-n" 8
.IX Item "(-n"
{x | x<=n}
.IP "n\-)" 8
.IX Item "n-)"
{x | x>=n}
.IP "(\-)" 8
The set of all integers
.SS "Empty forms"
.IX Subsection "Empty forms"
The empty set is consistently written as '' (the null string).
It is also denoted by the special form '\-' (a single dash).
.SS "Restrictions"
.IX Subsection "Restrictions"
The runs in a run list must be disjoint,
and must be listed in increasing order.
.PP
Valid characters in a run list are 0\-9, '(', ')', '\-' and ','.
White space and underscore (_) are ignored.
Other characters are not allowed.
.SS "Examples"
.IX Subsection "Examples"
.IP "\-" 15
{ }
.IP "1" 15
.IX Item "1"
{ 1 }
.IP "1\-2" 15
.IX Item "1-2"
{ 1, 2 }
.IP "\-5\-\-1" 15
.IX Item "-5--1"
{ \-5, \-4, \-3, \-2, \-1 }
.IP "(\-)" 15
the integers
.IP "(\-\-1" 15
.IX Item "(--1"
the negative integers
.IP "1\-3, 4, 18\-21" 15
.IX Item "1-3, 4, 18-21"
{ 1, 2, 3, 4, 18, 19, 20, 21 }
.SH "METHODS"
.IX Header "METHODS"
.SS "Creation"
.IX Subsection "Creation"
.ie n .IP "new Bio::GMOD::Blast::Graph::IntSpan $set_spec;" 4
.el .IP "new Bio::GMOD::Blast::Graph::IntSpan \f(CW$set_spec\fR;" 4
.IX Item "new Bio::GMOD::Blast::Graph::IntSpan $set_spec;"
Creates and returns a new set.
The initial contents of the set are given by \f(CW$set_spec\fR.
.ie n .IP "valid Bio::GMOD::Blast::Graph::IntSpan $run_list;" 4
.el .IP "valid Bio::GMOD::Blast::Graph::IntSpan \f(CW$run_list\fR;" 4
.IX Item "valid Bio::GMOD::Blast::Graph::IntSpan $run_list;"
Returns true if \f(CW$run_list\fR is a valid run list.
Otherwise, returns false and leaves an error message in $@.
.ie n .IP "copy $set $set_spec;" 4
.el .IP "copy \f(CW$set\fR \f(CW$set_spec\fR;" 4
.IX Item "copy $set $set_spec;"
Copies \f(CW$set_spec\fR into \f(CW$set\fR.
The previous contents of \f(CW$set\fR are lost.
For convenience, \fIcopy()\fR returns \f(CW$set\fR.
.ie n .IP "$run_list = run_list $set" 4
.el .IP "\f(CW$run_list\fR = run_list \f(CW$set\fR" 4
.IX Item "$run_list = run_list $set"
Returns a run list that represents \f(CW$set\fR.
The run list will not contain white space.
\&\f(CW$set\fR is not affected.
.Sp
By default, the empty set is formatted as '\-';
a different string may be specified in \f(CW$Bio::GMOD::Blast::Graph::IntSpan::Empty_String\fR.
.ie n .IP "@elements = elements $set;" 4
.el .IP "\f(CW@elements\fR = elements \f(CW$set\fR;" 4
.IX Item "@elements = elements $set;"
Returns an array containing the elements of \f(CW$set\fR.
The elements will be sorted in numerical order.
In scalar context, returns an array reference.
\&\f(CW$set\fR is not affected.
.SS "Set operations"
.IX Subsection "Set operations"
.ie n .IP "$u_set = union $set $set_spec;" 4
.el .IP "\f(CW$u_set\fR = union \f(CW$set\fR \f(CW$set_spec\fR;" 4
.IX Item "$u_set = union $set $set_spec;"
returns the set of integers in either \f(CW$set\fR or \f(CW$set_spec\fR
.ie n .IP "$i_set = intersect $set $set_spec;" 4
.el .IP "\f(CW$i_set\fR = intersect \f(CW$set\fR \f(CW$set_spec\fR;" 4
.IX Item "$i_set = intersect $set $set_spec;"
returns the set of integers in both \f(CW$set\fR and \f(CW$set_spec\fR
.ie n .IP "$x_set = xor $set $set_spec;" 4
.el .IP "\f(CW$x_set\fR = xor \f(CW$set\fR \f(CW$set_spec\fR;" 4
.IX Item "$x_set = xor $set $set_spec;"
returns the set of integers in \f(CW$set\fR or \f(CW$set_spec\fR, but not both
.ie n .IP "$d_set = diff $set $set_spec;" 4
.el .IP "\f(CW$d_set\fR = diff \f(CW$set\fR \f(CW$set_spec\fR;" 4
.IX Item "$d_set = diff $set $set_spec;"
returns the set of integers in \f(CW$set\fR but not in \f(CW$set_spec\fR
.ie n .IP "$c_set = complement $set;" 4
.el .IP "\f(CW$c_set\fR = complement \f(CW$set\fR;" 4
.IX Item "$c_set = complement $set;"
returns the complement of \f(CW$set\fR.
.PP
For all set operations, a new Bio::GMOD::Blast::Graph::IntSpan object is created and returned.
The operands are not affected.
.SS "Comparison"
.IX Subsection "Comparison"
.ie n .IP "equal $set $set_spec;" 4
.el .IP "equal \f(CW$set\fR \f(CW$set_spec\fR;" 4
.IX Item "equal $set $set_spec;"
Returns true iff \f(CW$set\fR and \f(CW$set_spec\fR contain the same elements.
.ie n .IP "equivalent $set $set_spec;" 4
.el .IP "equivalent \f(CW$set\fR \f(CW$set_spec\fR;" 4
.IX Item "equivalent $set $set_spec;"
Returns true iff \f(CW$set\fR and \f(CW$set_spec\fR contain the same number of elements.
All infinite sets are equivalent.
.ie n .IP "superset $set $set_spec" 4
.el .IP "superset \f(CW$set\fR \f(CW$set_spec\fR" 4
.IX Item "superset $set $set_spec"
Returns true iff \f(CW$set\fR is a superset of \f(CW$set_spec\fR.
.ie n .IP "subset $set $set_spec" 4
.el .IP "subset \f(CW$set\fR \f(CW$set_spec\fR" 4
.IX Item "subset $set $set_spec"
Returns true iff \f(CW$set\fR is a subset of \f(CW$set_spec\fR.
.SS "Cardinality"
.IX Subsection "Cardinality"
.ie n .IP "$n = cardinality $set" 4
.el .IP "\f(CW$n\fR = cardinality \f(CW$set\fR" 4
.IX Item "$n = cardinality $set"
Returns the number of elements in \f(CW$set\fR.
Returns \-1 for infinite sets.
.ie n .IP "empty $set;" 4
.el .IP "empty \f(CW$set\fR;" 4
.IX Item "empty $set;"
Returns true iff \f(CW$set\fR is empty.
.ie n .IP "finite $set" 4
.el .IP "finite \f(CW$set\fR" 4
.IX Item "finite $set"
Returns true iff \f(CW$set\fR is finite.
.ie n .IP "neg_inf $set" 4
.el .IP "neg_inf \f(CW$set\fR" 4
.IX Item "neg_inf $set"
Returns true iff \f(CW$set\fR contains {x | x<n} for some n.
.ie n .IP "pos_inf $set" 4
.el .IP "pos_inf \f(CW$set\fR" 4
.IX Item "pos_inf $set"
Returns true iff \f(CW$set\fR contains {x | x>n} for some n.
.ie n .IP "infinite $set" 4
.el .IP "infinite \f(CW$set\fR" 4
.IX Item "infinite $set"
Returns true iff \f(CW$set\fR is infinite.
.ie n .IP "universal $set" 4
.el .IP "universal \f(CW$set\fR" 4
.IX Item "universal $set"
Returns true iff \f(CW$set\fR contains all integers.
.SS "Membership"
.IX Subsection "Membership"
.ie n .IP "member $set $n" 4
.el .IP "member \f(CW$set\fR \f(CW$n\fR" 4
.IX Item "member $set $n"
Returns true iff the integer \f(CW$n\fR is a member of \f(CW$set\fR.
.ie n .IP "insert $set $n" 4
.el .IP "insert \f(CW$set\fR \f(CW$n\fR" 4
.IX Item "insert $set $n"
Inserts the integer \f(CW$n\fR into \f(CW$set\fR.
Does nothing if \f(CW$n\fR is already a member of \f(CW$set\fR.
.ie n .IP "remove $set $n" 4
.el .IP "remove \f(CW$set\fR \f(CW$n\fR" 4
.IX Item "remove $set $n"
Removes the integer \f(CW$n\fR from \f(CW$set\fR.
Does nothing if \f(CW$n\fR is not a member of \f(CW$set\fR.
.SS "Extrema"
.IX Subsection "Extrema"
.ie n .IP "min $set" 4
.el .IP "min \f(CW$set\fR" 4
.IX Item "min $set"
Returns the smallest element of \f(CW$set\fR,
or undef if there is none.
.ie n .IP "max $set" 4
.el .IP "max \f(CW$set\fR" 4
.IX Item "max $set"
Returns the largest element of \f(CW$set\fR,
or undef if there is none.
.SH "CLASS VARIABLES"
.IX Header "CLASS VARIABLES"
.ie n .IP "$Bio::GMOD::Blast::Graph::IntSpan::Empty_String" 4
.el .IP "\f(CW$Bio::GMOD::Blast::Graph::IntSpan::Empty_String\fR" 4
.IX Item "$Bio::GMOD::Blast::Graph::IntSpan::Empty_String"
\&\f(CW$Bio::GMOD::Blast::Graph::IntSpan::Empty_String\fR contains the string that is returned when
\&\fIrun_list()\fR is called on the empty set.
\&\f(CW$Empty_String\fR is initially '\-';
alternatively, it may be set to ''.
Other values should be avoided,
to ensure that \fIrun_list()\fR always returns a valid run list.
.Sp
\&\fIrun_list()\fR accesses \f(CW$Empty_String\fR through a reference
stored in \f(CW$set\fR\->{empty_string}.
Subclasses that wish to override the value of \f(CW$Empty_String\fR can
reassign this reference.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
Any method (except \fIvalid()\fR) will \fIdie()\fR if it is passed an invalid run list.
Possible messages are:
.IP "Bad syntax" 15
.IX Item "Bad syntax"
\&\f(CW$run_list\fR has bad syntax
.IP "Bad order" 15
.IX Item "Bad order"
\&\f(CW$run_list\fR has overlapping runs or runs that are out of order.
.PP
elements \f(CW$set\fR will \fIdie()\fR if \f(CW$set\fR is infinite.
.PP
elements \f(CW$set\fR can generate an \*(L"Out of memory!\*(R"
message on sufficiently large finite sets.
.SH "NOTES"
.IX Header "NOTES"
.SS "Traps"
.IX Subsection "Traps"
Beware of forms like
.PP
.Vb 1
\&    union $set [1..5];
.Ve
.PP
This passes an element of \f(CW@set\fR to union,
which is probably not what you want.
To force interpretation of \f(CW$set\fR and [1..5] as separate arguments,
use forms like
.PP
.Vb 1
\&    union $set +[1..5];
.Ve
.PP
or
.PP
.Vb 1
\&    $set\->union([1..5]);
.Ve
.SS "Error handling"
.IX Subsection "Error handling"
There are two common approaches to error handling:
exceptions and return codes.
There seems to be some religion on the topic,
so Bio::GMOD::Blast::Graph::IntSpan provides support for both.
.PP
To catch exceptions, protect method calls with an eval:
.PP
.Vb 3
\&    $run_list = <STDIN>;
\&    eval { $set = new Bio::GMOD::Blast::Graph::IntSpan $run_list };
\&    $@ and print "$@: try again\en";
.Ve
.PP
To check return codes, use an appropriate method call to validate arguments:
.PP
.Vb 5
\&    $run_list = <STDIN>;
\&    if (valid Bio::GMOD::Blast::Graph::IntSpan $run_list)
\&       { $set = new Bio::GMOD::Blast::Graph::IntSpan $run_list }
\&    else
\&       { print "$@ try again\en" }
.Ve
.PP
Similarly, use \fIfinite()\fR to protect calls to \fIelements()\fR:
.PP
.Vb 1
\&    finite $set and @elements = elements $set;
.Ve
.PP
Calling \fIelements()\fR on a large, finite set can generate an \*(L"Out of
memory!\*(R" message, which cannot be trapped.
Applications that must retain control after an error can use \fIintersect()\fR to
protect calls to \fIelements()\fR:
.PP
.Vb 1
\&    @elements = elements { intersect $set "\-1_000_000 \- 1_000_000" };
.Ve
.PP
or check the size of \f(CW$set\fR first:
.PP
.Vb 1
\&    finite $set and cardinality $set < 2_000_000 and @elements = elements $set;
.Ve
.SS "Limitations"
.IX Subsection "Limitations"
Although Bio::GMOD::Blast::Graph::IntSpan can represent some infinite sets,
it does \fInot\fR perform infinite-precision arithmetic.
Therefore,
finite elements are restricted to the range of integers on your machine.
.SS "Roots"
.IX Subsection "Roots"
The sets implemented here are based on Macintosh data structures called
\&\*(L"regions\*(R".
See Inside Macintosh for more information.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steven McDougall <swm@cric.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1996 Steven McDougall.
All rights reserved.
This module is free software;
you can redistribute it and/or modify it under the same terms as Perl itself.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 159:" 4
.IX Item "Around line 159:"
You forgot a '=back' before '=head2'
.IP "Around line 161:" 4
.IX Item "Around line 161:"
\&'=item' outside of any '=over'
